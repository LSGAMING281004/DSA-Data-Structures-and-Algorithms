# DSA-Data-Structures-and-Algorithms
DSA is the backbone of efficient programming. Itâ€™s all about:  Data Structures: Ways to organize and store data (e.g., arrays, linked lists, trees, graphs).  Algorithms: Step-by-step procedures to solve problems (e.g., sorting, searching, traversing).
______________________________________________________________________________________________________________________________________________________________________________
âš¡ Common Sorting Algorithms and When They Shine
1. Bubble Sort â†’ Simple to learn, but inefficient. Best only for teaching basics.
2. Selection Sort â†’ Easy to implement, but always 
ğ‘‚
(
ğ‘›
2
)
. Rarely used in practice.
3. Insertion Sort â†’ Great for small or nearly sorted arrays. Fast in best case (
ğ‘‚
(
ğ‘›
)
).
4. Merge Sort â†’ Stable, predictable 
ğ‘‚
(
ğ‘›
log
â¡
ğ‘›
)
. Excellent for large datasets where stability matters.
5. Quick Sort â†’ Very fast on average (
ğ‘‚
(
ğ‘›
log
â¡
ğ‘›
)
), widely used. But worst case is 
ğ‘‚
(
ğ‘›
2
)
.
6. Heap Sort â†’ Guaranteed 
ğ‘‚
(
ğ‘›
log
â¡
ğ‘›
)
, but not stable. Good when memory is tight.
7. Counting Sort â†’ Non-comparison sort, blazing fast (
ğ‘‚
(
ğ‘›+
ğ‘˜
)
) for integers in a limited range.
8. Radix Sort â†’ Efficient for large numbers/strings, especially when keys have fixed length.
9. Tim Sort â†’ Hybrid of merge + insertion sort. Used in Javaâ€™s Arrays.sort() and Pythonâ€™s sorted().
<img width="548" height="314" alt="Screenshot 2026-01-10 204600" src="https://github.com/user-attachments/assets/53dd433d-e3a8-4870-bd2e-c640a687db75" />

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ğŸ” Common Searching Algorithms
1. Linear Search: Check each element one by one until you find the target.
2. Binary Search: Works on sorted arrays; repeatedly divides the search space in half.
3. Jump Search: Skips ahead by fixed steps, then does linear search in a block.
4. Interpolation Search: Estimates position based on value distribution (like searching in a phone book).
5. Exponential Search: Expands range exponentially, then applies binary search.
6. Hashing: Uses hash tables for near-instant lookups.
7. Ternary Search: Splits array into three parts; useful for unimodal functions.
<img width="494" height="336" alt="image" src="https://github.com/user-attachments/assets/b8051e37-b198-4304-b51e-802d66fbdb1e" />

------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

=> Time Complexity Graph
![1_5ZLci3SuR0zM_QlZOADv8Q](https://github.com/user-attachments/assets/36e06888-5248-4702-b042-8d83e4c8257d)


